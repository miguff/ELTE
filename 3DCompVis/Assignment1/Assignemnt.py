import cv2
import random
import numpy as np
from sympy.matrices import Matrix

# Disclaimer:
# Code comments generated by ChatGPT

def main():
    """
    Main function to perform RANSAC-based line intersection estimation.
    It detects lines in an image, uses RANSAC to estimate the best intersection point,
    and draws the result on the image, including an optimized intersection point.
    """
    name = "ELTECar4.png"
    image = cv2.imread(name, 0)
    lsd = cv2.createLineSegmentDetector(0)
    lines = lsd.detect(image)[0]
    linend = lines[:,0,:]
    lambdavalue = 5
    NumberofRansacIter = 150
    ################### RANSAC Eatimation
    inliners, bestx, besty = RANSACEstimation(NumberofRansacIter, lines, linend, lambdavalue)

    ############## We need to redo the estimation
    finalError = 1000000 # Initialize a high error for optimization
    newx = None
    newy = None
    for i in range(len(inliners)):
        for j in range(i+1, len(inliners)):
            # Calculate intersection point of two inlier lines
            candidatepoint = intersection(inliners[i], inliners[j])
            intersectx, intersecty = candidatepoint
            # Calculate mean squared error for this candidate point
            errors = []
            for k in inliners:
                x1, y1, x2, y2 = k.flatten()
                m = (y2-y1)/(x2-x1)
                b = y1 - m*x1
                ycap = intersectx*m + b
                ydiff = ycap - intersecty
                errors.append(ydiff)
            squared_errors = [e ** 2 for e in errors] 
            mse = np.mean(squared_errors)
            # Update best intersection point if a lower error is found
            if mse < finalError:
                newx = intersectx
                newy = intersecty
                finalError = mse
    
    # Draw all detected line segments and the best intersection point
    image = lsd.drawSegments(image, inliners)
    # Offset for visualization
    bestx = bestx+image.shape[1]
    newx = newx+image.shape[1]
    black = np.zeros(image.shape) # Create a black image for line visualization
    drawn_img = np.concatenate((black, image), axis=1) # Concatenate original with black image

    for z in range(len(inliners)):
        x1, y1, x2, y2 = int(inliners[z][0][0]), int(inliners[z][0][1]), int(inliners[z][0][2]), int(inliners[z][0][3])
        x1 = x1+image.shape[1] #starting point
        x2 = x2+image.shape[1] #Ending point
        pt1 = (x1, y1)  
        pt2 = (x2, y2)  

        color = (0, 255, 0)   # Color
        thickness = 2  # Thickness for the line

         # Extend line segment to image borders
        if x2 - x1 != 0:  #Cehck for non vertical lines
            slope = (y2 - y1) / (x2- x1)
            intercept = y1 - slope * x1


            # Calculate y-values for line extension at image borders
            y_start = int(slope * 0 + intercept)  # y at x = 0 (left border)
            y_end = int(slope * drawn_img.shape[1] + intercept)  # y at x = image width (right border)  
            
            #Draw the extended line
            cv2.line(drawn_img, (0, y_start), (drawn_img.shape[1], y_end), (0, 0, 255), 2)
        else:

            cv2.line(drawn_img, (x1, 0), (x1, drawn_img.shape[0]), (0, 0, 255), 2)
        # Draw the original line segment in green
        drawn_img = cv2.line(drawn_img, pt1, pt2, color, thickness)
           
    
    #Original
    drawn_img = cv2.circle(drawn_img, (bestx,besty), radius=10, color=(255, 0, 0), thickness=-1)
    #Reoptimization
    drawn_img = cv2.circle(drawn_img, (newx,newy), radius=10, color=(0, 255, 0), thickness=-1)
    
    # Save and display the final image
    cv2.imwrite(f"RANSAC_{name}", drawn_img)
    cv2.imshow(f"RANSAC_{name}", drawn_img)


    cv2.waitKey(0)
    cv2.destroyAllWindows()


def RANSACEstimation(NumberofRansacIter, lines, linend, lambdavalue):
    """
    Perform RANSAC to find the best intersection point for given lines.
    
    Args:
        NumberofRansacIter (int): Number of RANSAC iterations.
        lines (array): Array of line segments.
        linend (array): Array of line endpoints.
        lambdavalue (float): Distance threshold for considering inliers.
        
    Returns:
        np.array: Array of inlier lines.
        float: x-coordinate of the best intersection point.
        float: y-coordinate of the best intersection point.
    """
    inliners = []
    bestx = None
    besty = None
    for j in range(NumberofRansacIter):
        insideinliner = []
        # Randomly select two lines and calculate their intersection point
        line1, line2 = random.sample(list(lines), 2)
        candidatepoint = intersection(line1, line2)
        intersectx, intersecty = candidatepoint
        
        # Determine if other lines are inliers to this intersection point
        for i in linend:
            x1, y1, x2, y2 = i.flatten()
            m = (y2-y1)/(x2-x1)
            b = y1 - m*x1
            ycap = intersectx*m + b
            ydiff = ycap - intersecty
            if abs(ydiff) < lambdavalue:
                insideinliner.append(i)
        print(f"Number of inliners in the {j}. Step: {len(insideinliner)}.")
        # Update best inlier set if a larger inlier count is found
        if len(insideinliner) > len(inliners):
            print(f"Now I change the insiders.")
            inliners = insideinliner
            bestx = intersectx
            besty = intersecty
    print(f"Lenghts of the final inliners: {len(inliners)}")    
    inliners = np.array(inliners).reshape(-1, 1, 4)

    return inliners, bestx, besty


def intersection(line1, line2):
    """
    Calculate the intersection point of two lines.
    
    Args:
        line1 (array): First line segment with two endpoints.
        line2 (array): Second line segment with two endpoints.
        
    Returns:
        tuple: (x, y) coordinates of the intersection point.
    """
    x1, y1, x2, y2 = line1.flatten()
    x3, y3, x4, y4 = line2.flatten()


    #Parameters of line1
    A1 = y2 - y1
    B1 = x1 - x2

    #Plug in one point of the line
    C1 = A1*x1 + B1*y1

    #Parameters of line2
    A2 = y4 - y3
    B2 = x3 - x4

    #Plug in one point of the line
    C2 = A2 * x3 + B2 * y3

    determinant = A1*B2 - B1*A2
    if determinant == 0:
        print("This line are paralell")
    else:
        # Using sympy's rref() to find intersection
        AugmentedMatrix = Matrix([[A1, B1, C1],
          [A2, B2, C2]])
    
        rref_matrix, _ = AugmentedMatrix.rref()

        x = int(rref_matrix[0, 2])
        y = int(rref_matrix[1, 2])
    
    return x, y
    

if __name__ == "__main__":
    main()